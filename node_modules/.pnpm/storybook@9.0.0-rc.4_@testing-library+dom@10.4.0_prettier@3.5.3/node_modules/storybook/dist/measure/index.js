var H = Object.defineProperty;
var l = (e, t) => H(e, "name", { value: t, configurable: !0 });
var st = (e, t) => {
  for (var o in t)
    H(e, o, { get: t[o], enumerable: !0 });
};

// src/measure/index.ts
import { definePreview as Tt } from "storybook/preview-api";

// src/measure/preview.ts
var P = {};
st(P, {
  decorators: () => Q,
  default: () => xt,
  initialGlobals: () => J
});
import { definePreview as Mt } from "storybook/preview-api";

// src/measure/constants.ts
var C = "storybook/measure-addon", kt = `${C}/tool`, F = "measureEnabled", Pt = {
  RESULT: `${C}/result`,
  REQUEST: `${C}/request`,
  CLEAR: `${C}/clear`
};

// src/measure/withMeasure.ts
import { useEffect as U } from "storybook/preview-api";

// src/measure/box-model/canvas.ts
import { global as R } from "@storybook/global";

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var ft = !1, T = "Invariant failed";
function v(e, t) {
  if (!e) {
    if (ft)
      throw new Error(T);
    var o = typeof t == "function" ? t() : t, i = o ? "".concat(T, ": ").concat(o) : T;
    throw new Error(i);
  }
}
l(v, "invariant");

// src/measure/box-model/canvas.ts
function W() {
  let e = R.document.documentElement, t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
l(W, "getDocumentWidthAndHeight");
function ct() {
  let e = R.document.createElement("canvas");
  e.id = "storybook-addon-measure";
  let t = e.getContext("2d");
  v(t != null);
  let { width: o, height: i } = W();
  return D(e, t, { width: o, height: i }), e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.style.zIndex = "214748364\
7", e.style.pointerEvents = "none", R.document.body.appendChild(e), { canvas: e, context: t, width: o, height: i };
}
l(ct, "createCanvas");
function D(e, t, { width: o, height: i }) {
  e.style.width = `${o}px`, e.style.height = `${i}px`;
  let n = R.window.devicePixelRatio;
  e.width = Math.floor(o * n), e.height = Math.floor(i * n), t.scale(n, n);
}
l(D, "setCanvasWidthAndHeight");
var m = {};
function Y() {
  m.canvas || (m = ct());
}
l(Y, "init");
function B() {
  m.context && m.context.clearRect(0, 0, m.width ?? 0, m.height ?? 0);
}
l(B, "clear");
function z(e) {
  B(), e(m.context);
}
l(z, "draw");
function X() {
  v(m.canvas, "Canvas should exist in the state."), v(m.context, "Context should exist in the state."), D(m.canvas, m.context, { width: 0, height: 0 });
  let { width: e, height: t } = W();
  D(m.canvas, m.context, { width: e, height: t }), m.width = e, m.height = t;
}
l(X, "rescale");
function $() {
  m.canvas && (B(), m.canvas.parentNode?.removeChild(m.canvas), m = {});
}
l($, "destroy");

// src/measure/box-model/visualizer.ts
import { global as b } from "@storybook/global";

// src/measure/box-model/labels.ts
var w = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, g = 6;
function N(e, { x: t, y: o, w: i, h: n, r }) {
  t = t - i / 2, o = o - n / 2, i < 2 * r && (r = i / 2), n < 2 * r && (r = n / 2), e.beginPath(), e.moveTo(t + r, o), e.arcTo(t + i, o, t +
  i, o + n, r), e.arcTo(t + i, o + n, t, o + n, r), e.arcTo(t, o + n, t, o, r), e.arcTo(t, o, t + i, o, r), e.closePath();
}
l(N, "roundedRect");
function mt(e, { padding: t, border: o, width: i, height: n, top: r, left: a }) {
  let s = i - o.left - o.right - t.left - t.right, f = n - t.top - t.bottom - o.top - o.bottom, c = a + o.left + t.left, u = r + o.top + t.top;
  return e === "top" ? c += s / 2 : e === "right" ? (c += s, u += f / 2) : e === "bottom" ? (c += s / 2, u += f) : e === "left" ? u += f / 2 :
  e === "center" && (c += s / 2, u += f / 2), { x: c, y: u };
}
l(mt, "positionCoordinate");
function ut(e, t, { margin: o, border: i, padding: n }, r, a) {
  let s = /* @__PURE__ */ l((d) => 0, "shift"), f = 0, c = 0, u = a ? 1 : 0.5, h = a ? r * 2 : 0;
  return e === "padding" ? s = /* @__PURE__ */ l((d) => n[d] * u + h, "shift") : e === "border" ? s = /* @__PURE__ */ l((d) => n[d] + i[d] *
  u + h, "shift") : e === "margin" && (s = /* @__PURE__ */ l((d) => n[d] + i[d] + o[d] * u + h, "shift")), t === "top" ? c = -s("top") : t ===
  "right" ? f = s("right") : t === "bottom" ? c = s("bottom") : t === "left" && (f = -s("left")), { offsetX: f, offsetY: c };
}
l(ut, "offset");
function dt(e, t) {
  return Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2;
}
l(dt, "collide");
function ht(e, t, o) {
  return e === "top" ? t.y = o.y - o.h - g : e === "right" ? t.x = o.x + o.w / 2 + g + t.w / 2 : e === "bottom" ? t.y = o.y + o.h + g : e ===
  "left" && (t.x = o.x - o.w / 2 - g - t.w / 2), { x: t.x, y: t.y };
}
l(ht, "overlapAdjustment");
function O(e, t, { x: o, y: i, w: n, h: r }, a) {
  return N(e, { x: o, y: i, w: n, h: r, r: 3 }), e.fillStyle = `${w[t]}dd`, e.fill(), e.strokeStyle = w[t], e.stroke(), e.fillStyle = w.text,
  e.fillText(a, o, i), N(e, { x: o, y: i, w: n, h: r, r: 3 }), e.fillStyle = `${w[t]}dd`, e.fill(), e.strokeStyle = w[t], e.stroke(), e.fillStyle =
  w.text, e.fillText(a, o, i), { x: o, y: i, w: n, h: r };
}
l(O, "textWithRect");
function I(e, t) {
  e.font = "600 12px monospace", e.textBaseline = "middle", e.textAlign = "center";
  let o = e.measureText(t), i = o.actualBoundingBoxAscent + o.actualBoundingBoxDescent, n = o.width + g * 2, r = i + g * 2;
  return { w: n, h: r };
}
l(I, "configureText");
function pt(e, t, { type: o, position: i = "center", text: n }, r, a = !1) {
  let { x: s, y: f } = mt(i, t), { offsetX: c, offsetY: u } = ut(o, i, t, g + 1, a);
  s += c, f += u;
  let { w: h, h: d } = I(e, n);
  if (r && dt({ x: s, y: f, w: h, h: d }, r)) {
    let S = ht(i, { x: s, y: f, w: h, h: d }, r);
    s = S.x, f = S.y;
  }
  return O(e, o, { x: s, y: f, w: h, h: d }, n);
}
l(pt, "drawLabel");
function bt(e, { w: t, h: o }) {
  let i = t * 0.5 + g, n = o * 0.5 + g;
  return {
    offsetX: (e.x === "left" ? -1 : 1) * i,
    offsetY: (e.y === "top" ? -1 : 1) * n
  };
}
l(bt, "floatingOffset");
function gt(e, t, { type: o, text: i }) {
  let { floatingAlignment: n, extremities: r } = t, a = r[n.x], s = r[n.y], { w: f, h: c } = I(e, i), { offsetX: u, offsetY: h } = bt(n, {
    w: f,
    h: c
  });
  return a += u, s += h, O(e, o, { x: a, y: s, w: f, h: c }, i);
}
l(gt, "drawFloatingLabel");
function y(e, t, o, i) {
  let n = [];
  o.forEach((r, a) => {
    let s = i && r.position === "center" ? gt(e, t, r) : pt(e, t, r, n[a - 1], i);
    n[a] = s;
  });
}
l(y, "drawStack");
function _(e, t, o, i) {
  let n = o.reduce((r, a) => (Object.prototype.hasOwnProperty.call(r, a.position) || (r[a.position] = []), r[a.position]?.push(a), r), {});
  n.top && y(e, t, n.top, i), n.right && y(e, t, n.right, i), n.bottom && y(e, t, n.bottom, i), n.left && y(e, t, n.left, i), n.center && y(
  e, t, n.center, i);
}
l(_, "labelStacks");

// src/measure/box-model/visualizer.ts
var M = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, q = 30;
function p(e) {
  return parseInt(e.replace("px", ""), 10);
}
l(p, "pxToNumber");
function L(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
l(L, "round");
function k(e) {
  return e.filter((t) => t.text !== 0 && t.text !== "0");
}
l(k, "filterZeroValues");
function wt(e) {
  let t = {
    top: b.window.scrollY,
    bottom: b.window.scrollY + b.window.innerHeight,
    left: b.window.scrollX,
    right: b.window.scrollX + b.window.innerWidth
  }, o = {
    top: Math.abs(t.top - e.top),
    bottom: Math.abs(t.bottom - e.bottom),
    left: Math.abs(t.left - e.left),
    right: Math.abs(t.right - e.right)
  };
  return {
    x: o.left > o.right ? "left" : "right",
    y: o.top > o.bottom ? "top" : "bottom"
  };
}
l(wt, "floatingAlignment");
function Lt(e) {
  let t = b.getComputedStyle(e), { top: o, left: i, right: n, bottom: r, width: a, height: s } = e.getBoundingClientRect(), {
    marginTop: f,
    marginBottom: c,
    marginLeft: u,
    marginRight: h,
    paddingTop: d,
    paddingBottom: S,
    paddingLeft: tt,
    paddingRight: et,
    borderBottomWidth: ot,
    borderTopWidth: nt,
    borderLeftWidth: it,
    borderRightWidth: rt
  } = t;
  o = o + b.window.scrollY, i = i + b.window.scrollX, r = r + b.window.scrollY, n = n + b.window.scrollX;
  let E = {
    top: p(f),
    bottom: p(c),
    left: p(u),
    right: p(h)
  }, lt = {
    top: p(d),
    bottom: p(S),
    left: p(tt),
    right: p(et)
  }, at = {
    top: p(nt),
    bottom: p(ot),
    left: p(it),
    right: p(rt)
  }, A = {
    top: o - E.top,
    bottom: r + E.bottom,
    left: i - E.left,
    right: n + E.right
  };
  return {
    margin: E,
    padding: lt,
    border: at,
    top: o,
    left: i,
    bottom: r,
    right: n,
    width: a,
    height: s,
    extremities: A,
    floatingAlignment: wt(A)
  };
}
l(Lt, "measureElement");
function Et(e, { margin: t, width: o, height: i, top: n, left: r, bottom: a, right: s }) {
  let f = i + t.bottom + t.top;
  e.fillStyle = M.margin, e.fillRect(r, n - t.top, o, t.top), e.fillRect(s, n - t.top, t.right, f), e.fillRect(r, a, o, t.bottom), e.fillRect(
  r - t.left, n - t.top, t.left, f);
  let c = [
    {
      type: "margin",
      text: L(t.top),
      position: "top"
    },
    {
      type: "margin",
      text: L(t.right),
      position: "right"
    },
    {
      type: "margin",
      text: L(t.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: L(t.left),
      position: "left"
    }
  ];
  return k(c);
}
l(Et, "drawMargin");
function yt(e, { padding: t, border: o, width: i, height: n, top: r, left: a, bottom: s, right: f }) {
  let c = i - o.left - o.right, u = n - t.top - t.bottom - o.top - o.bottom;
  e.fillStyle = M.padding, e.fillRect(a + o.left, r + o.top, c, t.top), e.fillRect(
    f - t.right - o.right,
    r + t.top + o.top,
    t.right,
    u
  ), e.fillRect(
    a + o.left,
    s - t.bottom - o.bottom,
    c,
    t.bottom
  ), e.fillRect(a + o.left, r + t.top + o.top, t.left, u);
  let h = [
    {
      type: "padding",
      text: t.top,
      position: "top"
    },
    {
      type: "padding",
      text: t.right,
      position: "right"
    },
    {
      type: "padding",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: t.left,
      position: "left"
    }
  ];
  return k(h);
}
l(yt, "drawPadding");
function St(e, { border: t, width: o, height: i, top: n, left: r, bottom: a, right: s }) {
  let f = i - t.top - t.bottom;
  e.fillStyle = M.border, e.fillRect(r, n, o, t.top), e.fillRect(r, a - t.bottom, o, t.bottom), e.fillRect(r, n + t.top, t.left, f), e.fillRect(
  s - t.right, n + t.top, t.right, f);
  let c = [
    {
      type: "border",
      text: t.top,
      position: "top"
    },
    {
      type: "border",
      text: t.right,
      position: "right"
    },
    {
      type: "border",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: t.left,
      position: "left"
    }
  ];
  return k(c);
}
l(St, "drawBorder");
function Ct(e, { padding: t, border: o, width: i, height: n, top: r, left: a }) {
  let s = i - o.left - o.right - t.left - t.right, f = n - t.top - t.bottom - o.top - o.bottom;
  return e.fillStyle = M.content, e.fillRect(
    a + o.left + t.left,
    r + o.top + t.top,
    s,
    f
  ), [
    {
      type: "content",
      position: "center",
      text: `${L(s)} x ${L(f)}`
    }
  ];
}
l(Ct, "drawContent");
function vt(e) {
  return (t) => {
    if (e && t) {
      let o = Lt(e), i = Et(t, o), n = yt(t, o), r = St(t, o), a = Ct(t, o), s = o.width <= q * 3 || o.height <= q;
      _(
        t,
        o,
        [...a, ...n, ...r, ...i],
        s
      );
    }
  };
}
l(vt, "drawBoxModel");
function j(e) {
  z(vt(e));
}
l(j, "drawSelectedElement");

// src/measure/util.ts
import { global as Rt } from "@storybook/global";
var G = /* @__PURE__ */ l((e, t) => {
  let o = Rt.document.elementFromPoint(e, t), i = /* @__PURE__ */ l((r) => {
    if (r && r.shadowRoot) {
      let a = r.shadowRoot.elementFromPoint(e, t);
      return r.isEqualNode(a) ? r : a.shadowRoot ? i(a) : a;
    }
    return r;
  }, "crawlShadows");
  return i(o) || o;
}, "deepElementFromPoint");

// src/measure/withMeasure.ts
var V, x = { x: 0, y: 0 };
function K(e, t) {
  V = G(e, t), j(V);
}
l(K, "findAndDrawElement");
var Z = /* @__PURE__ */ l((e, t) => {
  let { measureEnabled: o } = t.globals || {};
  return U(() => {
    if (typeof globalThis.document > "u")
      return;
    let i = /* @__PURE__ */ l((n) => {
      window.requestAnimationFrame(() => {
        n.stopPropagation(), x.x = n.clientX, x.y = n.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", i), () => {
      globalThis.document.removeEventListener("pointermove", i);
    };
  }, []), U(() => {
    let i = /* @__PURE__ */ l((r) => {
      window.requestAnimationFrame(() => {
        r.stopPropagation(), K(r.clientX, r.clientY);
      });
    }, "onPointerOver"), n = /* @__PURE__ */ l(() => {
      window.requestAnimationFrame(() => {
        X();
      });
    }, "onResize");
    return t.viewMode === "story" && o && (globalThis.document.addEventListener("pointerover", i), Y(), globalThis.window.addEventListener("\
resize", n), K(x.x, x.y)), () => {
      globalThis.window.removeEventListener("resize", n), $();
    };
  }, [o, t.viewMode]), e();
}, "withMeasure");

// src/measure/preview.ts
var Q = globalThis.FEATURES?.measure ? [Z] : [], J = {
  [F]: !1
}, xt = /* @__PURE__ */ l(() => Mt({
  decorators: Q,
  initialGlobals: J
}), "default");

// src/measure/index.ts
var le = /* @__PURE__ */ l(() => Tt(P), "default");
export {
  le as default
};
