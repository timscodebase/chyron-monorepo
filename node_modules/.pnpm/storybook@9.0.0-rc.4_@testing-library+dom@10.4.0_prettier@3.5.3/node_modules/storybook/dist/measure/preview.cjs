"use strict";
var v = Object.defineProperty;
var ft = Object.getOwnPropertyDescriptor;
var ct = Object.getOwnPropertyNames;
var mt = Object.prototype.hasOwnProperty;
var r = (e, t) => v(e, "name", { value: t, configurable: !0 });
var ut = (e, t) => {
  for (var o in t)
    v(e, o, { get: t[o], enumerable: !0 });
}, ht = (e, t, o, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of ct(t))
      !mt.call(e, n) && n !== o && v(e, n, { get: () => t[n], enumerable: !(i = ft(t, n)) || i.enumerable });
  return e;
};
var dt = (e) => ht(v({}, "__esModule", { value: !0 }), e);

// src/measure/preview.ts
var At = {};
ut(At, {
  decorators: () => J,
  default: () => Pt,
  initialGlobals: () => tt
});
module.exports = dt(At);
var Q = require("storybook/preview-api");

// src/measure/constants.ts
var R = "storybook/measure-addon", Ft = `${R}/tool`, F = "measureEnabled", Wt = {
  RESULT: `${R}/result`,
  REQUEST: `${R}/request`,
  CLEAR: `${R}/clear`
};

// src/measure/withMeasure.ts
var A = require("storybook/preview-api");

// src/measure/box-model/canvas.ts
var y = require("@storybook/global");

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var pt = process.env.NODE_ENV === "production", D = "Invariant failed";
function M(e, t) {
  if (!e) {
    if (pt)
      throw new Error(D);
    var o = typeof t == "function" ? t() : t, i = o ? "".concat(D, ": ").concat(o) : D;
    throw new Error(i);
  }
}
r(M, "invariant");

// src/measure/box-model/canvas.ts
function W() {
  let e = y.global.document.documentElement, t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
r(W, "getDocumentWidthAndHeight");
function bt() {
  let e = y.global.document.createElement("canvas");
  e.id = "storybook-addon-measure";
  let t = e.getContext("2d");
  M(t != null);
  let { width: o, height: i } = W();
  return k(e, t, { width: o, height: i }), e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.style.zIndex = "214748364\
7", e.style.pointerEvents = "none", y.global.document.body.appendChild(e), { canvas: e, context: t, width: o, height: i };
}
r(bt, "createCanvas");
function k(e, t, { width: o, height: i }) {
  e.style.width = `${o}px`, e.style.height = `${i}px`;
  let n = y.global.window.devicePixelRatio;
  e.width = Math.floor(o * n), e.height = Math.floor(i * n), t.scale(n, n);
}
r(k, "setCanvasWidthAndHeight");
var m = {};
function Y() {
  m.canvas || (m = bt());
}
r(Y, "init");
function B() {
  m.context && m.context.clearRect(0, 0, m.width ?? 0, m.height ?? 0);
}
r(B, "clear");
function z(e) {
  B(), e(m.context);
}
r(z, "draw");
function X() {
  M(m.canvas, "Canvas should exist in the state."), M(m.context, "Context should exist in the state."), k(m.canvas, m.context, { width: 0, height: 0 });
  let { width: e, height: t } = W();
  k(m.canvas, m.context, { width: e, height: t }), m.width = e, m.height = t;
}
r(X, "rescale");
function $() {
  m.canvas && (B(), m.canvas.parentNode?.removeChild(m.canvas), m = {});
}
r($, "destroy");

// src/measure/box-model/visualizer.ts
var b = require("@storybook/global");

// src/measure/box-model/labels.ts
var w = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, g = 6;
function N(e, { x: t, y: o, w: i, h: n, r: l }) {
  t = t - i / 2, o = o - n / 2, i < 2 * l && (l = i / 2), n < 2 * l && (l = n / 2), e.beginPath(), e.moveTo(t + l, o), e.arcTo(t + i, o, t +
  i, o + n, l), e.arcTo(t + i, o + n, t, o + n, l), e.arcTo(t, o + n, t, o, l), e.arcTo(t, o, t + i, o, l), e.closePath();
}
r(N, "roundedRect");
function gt(e, { padding: t, border: o, width: i, height: n, top: l, left: a }) {
  let s = i - o.left - o.right - t.left - t.right, f = n - t.top - t.bottom - o.top - o.bottom, c = a + o.left + t.left, u = l + o.top + t.top;
  return e === "top" ? c += s / 2 : e === "right" ? (c += s, u += f / 2) : e === "bottom" ? (c += s / 2, u += f) : e === "left" ? u += f / 2 :
  e === "center" && (c += s / 2, u += f / 2), { x: c, y: u };
}
r(gt, "positionCoordinate");
function wt(e, t, { margin: o, border: i, padding: n }, l, a) {
  let s = /* @__PURE__ */ r((h) => 0, "shift"), f = 0, c = 0, u = a ? 1 : 0.5, d = a ? l * 2 : 0;
  return e === "padding" ? s = /* @__PURE__ */ r((h) => n[h] * u + d, "shift") : e === "border" ? s = /* @__PURE__ */ r((h) => n[h] + i[h] *
  u + d, "shift") : e === "margin" && (s = /* @__PURE__ */ r((h) => n[h] + i[h] + o[h] * u + d, "shift")), t === "top" ? c = -s("top") : t ===
  "right" ? f = s("right") : t === "bottom" ? c = s("bottom") : t === "left" && (f = -s("left")), { offsetX: f, offsetY: c };
}
r(wt, "offset");
function Lt(e, t) {
  return Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2;
}
r(Lt, "collide");
function Et(e, t, o) {
  return e === "top" ? t.y = o.y - o.h - g : e === "right" ? t.x = o.x + o.w / 2 + g + t.w / 2 : e === "bottom" ? t.y = o.y + o.h + g : e ===
  "left" && (t.x = o.x - o.w / 2 - g - t.w / 2), { x: t.x, y: t.y };
}
r(Et, "overlapAdjustment");
function O(e, t, { x: o, y: i, w: n, h: l }, a) {
  return N(e, { x: o, y: i, w: n, h: l, r: 3 }), e.fillStyle = `${w[t]}dd`, e.fill(), e.strokeStyle = w[t], e.stroke(), e.fillStyle = w.text,
  e.fillText(a, o, i), N(e, { x: o, y: i, w: n, h: l, r: 3 }), e.fillStyle = `${w[t]}dd`, e.fill(), e.strokeStyle = w[t], e.stroke(), e.fillStyle =
  w.text, e.fillText(a, o, i), { x: o, y: i, w: n, h: l };
}
r(O, "textWithRect");
function I(e, t) {
  e.font = "600 12px monospace", e.textBaseline = "middle", e.textAlign = "center";
  let o = e.measureText(t), i = o.actualBoundingBoxAscent + o.actualBoundingBoxDescent, n = o.width + g * 2, l = i + g * 2;
  return { w: n, h: l };
}
r(I, "configureText");
function yt(e, t, { type: o, position: i = "center", text: n }, l, a = !1) {
  let { x: s, y: f } = gt(i, t), { offsetX: c, offsetY: u } = wt(o, i, t, g + 1, a);
  s += c, f += u;
  let { w: d, h } = I(e, n);
  if (l && Lt({ x: s, y: f, w: d, h }, l)) {
    let C = Et(i, { x: s, y: f, w: d, h }, l);
    s = C.x, f = C.y;
  }
  return O(e, o, { x: s, y: f, w: d, h }, n);
}
r(yt, "drawLabel");
function St(e, { w: t, h: o }) {
  let i = t * 0.5 + g, n = o * 0.5 + g;
  return {
    offsetX: (e.x === "left" ? -1 : 1) * i,
    offsetY: (e.y === "top" ? -1 : 1) * n
  };
}
r(St, "floatingOffset");
function Ct(e, t, { type: o, text: i }) {
  let { floatingAlignment: n, extremities: l } = t, a = l[n.x], s = l[n.y], { w: f, h: c } = I(e, i), { offsetX: u, offsetY: d } = St(n, {
    w: f,
    h: c
  });
  return a += u, s += d, O(e, o, { x: a, y: s, w: f, h: c }, i);
}
r(Ct, "drawFloatingLabel");
function S(e, t, o, i) {
  let n = [];
  o.forEach((l, a) => {
    let s = i && l.position === "center" ? Ct(e, t, l) : yt(e, t, l, n[a - 1], i);
    n[a] = s;
  });
}
r(S, "drawStack");
function _(e, t, o, i) {
  let n = o.reduce((l, a) => (Object.prototype.hasOwnProperty.call(l, a.position) || (l[a.position] = []), l[a.position]?.push(a), l), {});
  n.top && S(e, t, n.top, i), n.right && S(e, t, n.right, i), n.bottom && S(e, t, n.bottom, i), n.left && S(e, t, n.left, i), n.center && S(
  e, t, n.center, i);
}
r(_, "labelStacks");

// src/measure/box-model/visualizer.ts
var x = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, q = 30;
function p(e) {
  return parseInt(e.replace("px", ""), 10);
}
r(p, "pxToNumber");
function L(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
r(L, "round");
function P(e) {
  return e.filter((t) => t.text !== 0 && t.text !== "0");
}
r(P, "filterZeroValues");
function vt(e) {
  let t = {
    top: b.global.window.scrollY,
    bottom: b.global.window.scrollY + b.global.window.innerHeight,
    left: b.global.window.scrollX,
    right: b.global.window.scrollX + b.global.window.innerWidth
  }, o = {
    top: Math.abs(t.top - e.top),
    bottom: Math.abs(t.bottom - e.bottom),
    left: Math.abs(t.left - e.left),
    right: Math.abs(t.right - e.right)
  };
  return {
    x: o.left > o.right ? "left" : "right",
    y: o.top > o.bottom ? "top" : "bottom"
  };
}
r(vt, "floatingAlignment");
function Rt(e) {
  let t = b.global.getComputedStyle(e), { top: o, left: i, right: n, bottom: l, width: a, height: s } = e.getBoundingClientRect(), {
    marginTop: f,
    marginBottom: c,
    marginLeft: u,
    marginRight: d,
    paddingTop: h,
    paddingBottom: C,
    paddingLeft: et,
    paddingRight: ot,
    borderBottomWidth: nt,
    borderTopWidth: it,
    borderLeftWidth: lt,
    borderRightWidth: rt
  } = t;
  o = o + b.global.window.scrollY, i = i + b.global.window.scrollX, l = l + b.global.window.scrollY, n = n + b.global.window.scrollX;
  let E = {
    top: p(f),
    bottom: p(c),
    left: p(u),
    right: p(d)
  }, at = {
    top: p(h),
    bottom: p(C),
    left: p(et),
    right: p(ot)
  }, st = {
    top: p(it),
    bottom: p(nt),
    left: p(lt),
    right: p(rt)
  }, H = {
    top: o - E.top,
    bottom: l + E.bottom,
    left: i - E.left,
    right: n + E.right
  };
  return {
    margin: E,
    padding: at,
    border: st,
    top: o,
    left: i,
    bottom: l,
    right: n,
    width: a,
    height: s,
    extremities: H,
    floatingAlignment: vt(H)
  };
}
r(Rt, "measureElement");
function Mt(e, { margin: t, width: o, height: i, top: n, left: l, bottom: a, right: s }) {
  let f = i + t.bottom + t.top;
  e.fillStyle = x.margin, e.fillRect(l, n - t.top, o, t.top), e.fillRect(s, n - t.top, t.right, f), e.fillRect(l, a, o, t.bottom), e.fillRect(
  l - t.left, n - t.top, t.left, f);
  let c = [
    {
      type: "margin",
      text: L(t.top),
      position: "top"
    },
    {
      type: "margin",
      text: L(t.right),
      position: "right"
    },
    {
      type: "margin",
      text: L(t.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: L(t.left),
      position: "left"
    }
  ];
  return P(c);
}
r(Mt, "drawMargin");
function xt(e, { padding: t, border: o, width: i, height: n, top: l, left: a, bottom: s, right: f }) {
  let c = i - o.left - o.right, u = n - t.top - t.bottom - o.top - o.bottom;
  e.fillStyle = x.padding, e.fillRect(a + o.left, l + o.top, c, t.top), e.fillRect(
    f - t.right - o.right,
    l + t.top + o.top,
    t.right,
    u
  ), e.fillRect(
    a + o.left,
    s - t.bottom - o.bottom,
    c,
    t.bottom
  ), e.fillRect(a + o.left, l + t.top + o.top, t.left, u);
  let d = [
    {
      type: "padding",
      text: t.top,
      position: "top"
    },
    {
      type: "padding",
      text: t.right,
      position: "right"
    },
    {
      type: "padding",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: t.left,
      position: "left"
    }
  ];
  return P(d);
}
r(xt, "drawPadding");
function Tt(e, { border: t, width: o, height: i, top: n, left: l, bottom: a, right: s }) {
  let f = i - t.top - t.bottom;
  e.fillStyle = x.border, e.fillRect(l, n, o, t.top), e.fillRect(l, a - t.bottom, o, t.bottom), e.fillRect(l, n + t.top, t.left, f), e.fillRect(
  s - t.right, n + t.top, t.right, f);
  let c = [
    {
      type: "border",
      text: t.top,
      position: "top"
    },
    {
      type: "border",
      text: t.right,
      position: "right"
    },
    {
      type: "border",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: t.left,
      position: "left"
    }
  ];
  return P(c);
}
r(Tt, "drawBorder");
function Dt(e, { padding: t, border: o, width: i, height: n, top: l, left: a }) {
  let s = i - o.left - o.right - t.left - t.right, f = n - t.top - t.bottom - o.top - o.bottom;
  return e.fillStyle = x.content, e.fillRect(
    a + o.left + t.left,
    l + o.top + t.top,
    s,
    f
  ), [
    {
      type: "content",
      position: "center",
      text: `${L(s)} x ${L(f)}`
    }
  ];
}
r(Dt, "drawContent");
function kt(e) {
  return (t) => {
    if (e && t) {
      let o = Rt(e), i = Mt(t, o), n = xt(t, o), l = Tt(t, o), a = Dt(t, o), s = o.width <= q * 3 || o.height <= q;
      _(
        t,
        o,
        [...a, ...n, ...l, ...i],
        s
      );
    }
  };
}
r(kt, "drawBoxModel");
function j(e) {
  z(kt(e));
}
r(j, "drawSelectedElement");

// src/measure/util.ts
var G = require("@storybook/global");
var U = /* @__PURE__ */ r((e, t) => {
  let o = G.global.document.elementFromPoint(e, t), i = /* @__PURE__ */ r((l) => {
    if (l && l.shadowRoot) {
      let a = l.shadowRoot.elementFromPoint(e, t);
      return l.isEqualNode(a) ? l : a.shadowRoot ? i(a) : a;
    }
    return l;
  }, "crawlShadows");
  return i(o) || o;
}, "deepElementFromPoint");

// src/measure/withMeasure.ts
var V, T = { x: 0, y: 0 };
function K(e, t) {
  V = U(e, t), j(V);
}
r(K, "findAndDrawElement");
var Z = /* @__PURE__ */ r((e, t) => {
  let { measureEnabled: o } = t.globals || {};
  return (0, A.useEffect)(() => {
    if (typeof globalThis.document > "u")
      return;
    let i = /* @__PURE__ */ r((n) => {
      window.requestAnimationFrame(() => {
        n.stopPropagation(), T.x = n.clientX, T.y = n.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", i), () => {
      globalThis.document.removeEventListener("pointermove", i);
    };
  }, []), (0, A.useEffect)(() => {
    let i = /* @__PURE__ */ r((l) => {
      window.requestAnimationFrame(() => {
        l.stopPropagation(), K(l.clientX, l.clientY);
      });
    }, "onPointerOver"), n = /* @__PURE__ */ r(() => {
      window.requestAnimationFrame(() => {
        X();
      });
    }, "onResize");
    return t.viewMode === "story" && o && (globalThis.document.addEventListener("pointerover", i), Y(), globalThis.window.addEventListener("\
resize", n), K(T.x, T.y)), () => {
      globalThis.window.removeEventListener("resize", n), $();
    };
  }, [o, t.viewMode]), e();
}, "withMeasure");

// src/measure/preview.ts
var J = globalThis.FEATURES?.measure ? [Z] : [], tt = {
  [F]: !1
}, Pt = /* @__PURE__ */ r(() => (0, Q.definePreview)({
  decorators: J,
  initialGlobals: tt
}), "default");
