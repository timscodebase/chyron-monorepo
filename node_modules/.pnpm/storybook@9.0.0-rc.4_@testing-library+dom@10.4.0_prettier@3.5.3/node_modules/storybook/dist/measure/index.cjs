"use strict";
var v = Object.defineProperty;
var ut = Object.getOwnPropertyDescriptor;
var dt = Object.getOwnPropertyNames;
var ht = Object.prototype.hasOwnProperty;
var l = (e, t) => v(e, "name", { value: t, configurable: !0 });
var W = (e, t) => {
  for (var o in t)
    v(e, o, { get: t[o], enumerable: !0 });
}, pt = (e, t, o, i) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let n of dt(t))
      !ht.call(e, n) && n !== o && v(e, n, { get: () => t[n], enumerable: !(i = ut(t, n)) || i.enumerable });
  return e;
};
var bt = (e) => pt(v({}, "__esModule", { value: !0 }), e);

// src/measure/index.ts
var Wt = {};
W(Wt, {
  default: () => Ft
});
module.exports = bt(Wt);
var nt = require("storybook/preview-api");

// src/measure/preview.ts
var H = {};
W(H, {
  decorators: () => et,
  default: () => Ht,
  initialGlobals: () => ot
});
var tt = require("storybook/preview-api");

// src/measure/constants.ts
var R = "storybook/measure-addon", Bt = `${R}/tool`, Y = "measureEnabled", zt = {
  RESULT: `${R}/result`,
  REQUEST: `${R}/request`,
  CLEAR: `${R}/clear`
};

// src/measure/withMeasure.ts
var A = require("storybook/preview-api");

// src/measure/box-model/canvas.ts
var y = require("@storybook/global");

// ../node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var gt = process.env.NODE_ENV === "production", D = "Invariant failed";
function M(e, t) {
  if (!e) {
    if (gt)
      throw new Error(D);
    var o = typeof t == "function" ? t() : t, i = o ? "".concat(D, ": ").concat(o) : D;
    throw new Error(i);
  }
}
l(M, "invariant");

// src/measure/box-model/canvas.ts
function B() {
  let e = y.global.document.documentElement, t = Math.max(e.scrollHeight, e.offsetHeight);
  return { width: Math.max(e.scrollWidth, e.offsetWidth), height: t };
}
l(B, "getDocumentWidthAndHeight");
function wt() {
  let e = y.global.document.createElement("canvas");
  e.id = "storybook-addon-measure";
  let t = e.getContext("2d");
  M(t != null);
  let { width: o, height: i } = B();
  return k(e, t, { width: o, height: i }), e.style.position = "absolute", e.style.left = "0", e.style.top = "0", e.style.zIndex = "214748364\
7", e.style.pointerEvents = "none", y.global.document.body.appendChild(e), { canvas: e, context: t, width: o, height: i };
}
l(wt, "createCanvas");
function k(e, t, { width: o, height: i }) {
  e.style.width = `${o}px`, e.style.height = `${i}px`;
  let n = y.global.window.devicePixelRatio;
  e.width = Math.floor(o * n), e.height = Math.floor(i * n), t.scale(n, n);
}
l(k, "setCanvasWidthAndHeight");
var m = {};
function z() {
  m.canvas || (m = wt());
}
l(z, "init");
function X() {
  m.context && m.context.clearRect(0, 0, m.width ?? 0, m.height ?? 0);
}
l(X, "clear");
function $(e) {
  X(), e(m.context);
}
l($, "draw");
function N() {
  M(m.canvas, "Canvas should exist in the state."), M(m.context, "Context should exist in the state."), k(m.canvas, m.context, { width: 0, height: 0 });
  let { width: e, height: t } = B();
  k(m.canvas, m.context, { width: e, height: t }), m.width = e, m.height = t;
}
l(N, "rescale");
function O() {
  m.canvas && (X(), m.canvas.parentNode?.removeChild(m.canvas), m = {});
}
l(O, "destroy");

// src/measure/box-model/visualizer.ts
var b = require("@storybook/global");

// src/measure/box-model/labels.ts
var w = {
  margin: "#f6b26b",
  border: "#ffe599",
  padding: "#93c47d",
  content: "#6fa8dc",
  text: "#232020"
}, g = 6;
function I(e, { x: t, y: o, w: i, h: n, r }) {
  t = t - i / 2, o = o - n / 2, i < 2 * r && (r = i / 2), n < 2 * r && (r = n / 2), e.beginPath(), e.moveTo(t + r, o), e.arcTo(t + i, o, t +
  i, o + n, r), e.arcTo(t + i, o + n, t, o + n, r), e.arcTo(t, o + n, t, o, r), e.arcTo(t, o, t + i, o, r), e.closePath();
}
l(I, "roundedRect");
function Lt(e, { padding: t, border: o, width: i, height: n, top: r, left: a }) {
  let s = i - o.left - o.right - t.left - t.right, f = n - t.top - t.bottom - o.top - o.bottom, c = a + o.left + t.left, u = r + o.top + t.top;
  return e === "top" ? c += s / 2 : e === "right" ? (c += s, u += f / 2) : e === "bottom" ? (c += s / 2, u += f) : e === "left" ? u += f / 2 :
  e === "center" && (c += s / 2, u += f / 2), { x: c, y: u };
}
l(Lt, "positionCoordinate");
function Et(e, t, { margin: o, border: i, padding: n }, r, a) {
  let s = /* @__PURE__ */ l((d) => 0, "shift"), f = 0, c = 0, u = a ? 1 : 0.5, h = a ? r * 2 : 0;
  return e === "padding" ? s = /* @__PURE__ */ l((d) => n[d] * u + h, "shift") : e === "border" ? s = /* @__PURE__ */ l((d) => n[d] + i[d] *
  u + h, "shift") : e === "margin" && (s = /* @__PURE__ */ l((d) => n[d] + i[d] + o[d] * u + h, "shift")), t === "top" ? c = -s("top") : t ===
  "right" ? f = s("right") : t === "bottom" ? c = s("bottom") : t === "left" && (f = -s("left")), { offsetX: f, offsetY: c };
}
l(Et, "offset");
function yt(e, t) {
  return Math.abs(e.x - t.x) < Math.abs(e.w + t.w) / 2 && Math.abs(e.y - t.y) < Math.abs(e.h + t.h) / 2;
}
l(yt, "collide");
function St(e, t, o) {
  return e === "top" ? t.y = o.y - o.h - g : e === "right" ? t.x = o.x + o.w / 2 + g + t.w / 2 : e === "bottom" ? t.y = o.y + o.h + g : e ===
  "left" && (t.x = o.x - o.w / 2 - g - t.w / 2), { x: t.x, y: t.y };
}
l(St, "overlapAdjustment");
function _(e, t, { x: o, y: i, w: n, h: r }, a) {
  return I(e, { x: o, y: i, w: n, h: r, r: 3 }), e.fillStyle = `${w[t]}dd`, e.fill(), e.strokeStyle = w[t], e.stroke(), e.fillStyle = w.text,
  e.fillText(a, o, i), I(e, { x: o, y: i, w: n, h: r, r: 3 }), e.fillStyle = `${w[t]}dd`, e.fill(), e.strokeStyle = w[t], e.stroke(), e.fillStyle =
  w.text, e.fillText(a, o, i), { x: o, y: i, w: n, h: r };
}
l(_, "textWithRect");
function q(e, t) {
  e.font = "600 12px monospace", e.textBaseline = "middle", e.textAlign = "center";
  let o = e.measureText(t), i = o.actualBoundingBoxAscent + o.actualBoundingBoxDescent, n = o.width + g * 2, r = i + g * 2;
  return { w: n, h: r };
}
l(q, "configureText");
function Ct(e, t, { type: o, position: i = "center", text: n }, r, a = !1) {
  let { x: s, y: f } = Lt(i, t), { offsetX: c, offsetY: u } = Et(o, i, t, g + 1, a);
  s += c, f += u;
  let { w: h, h: d } = q(e, n);
  if (r && yt({ x: s, y: f, w: h, h: d }, r)) {
    let C = St(i, { x: s, y: f, w: h, h: d }, r);
    s = C.x, f = C.y;
  }
  return _(e, o, { x: s, y: f, w: h, h: d }, n);
}
l(Ct, "drawLabel");
function vt(e, { w: t, h: o }) {
  let i = t * 0.5 + g, n = o * 0.5 + g;
  return {
    offsetX: (e.x === "left" ? -1 : 1) * i,
    offsetY: (e.y === "top" ? -1 : 1) * n
  };
}
l(vt, "floatingOffset");
function Rt(e, t, { type: o, text: i }) {
  let { floatingAlignment: n, extremities: r } = t, a = r[n.x], s = r[n.y], { w: f, h: c } = q(e, i), { offsetX: u, offsetY: h } = vt(n, {
    w: f,
    h: c
  });
  return a += u, s += h, _(e, o, { x: a, y: s, w: f, h: c }, i);
}
l(Rt, "drawFloatingLabel");
function S(e, t, o, i) {
  let n = [];
  o.forEach((r, a) => {
    let s = i && r.position === "center" ? Rt(e, t, r) : Ct(e, t, r, n[a - 1], i);
    n[a] = s;
  });
}
l(S, "drawStack");
function j(e, t, o, i) {
  let n = o.reduce((r, a) => (Object.prototype.hasOwnProperty.call(r, a.position) || (r[a.position] = []), r[a.position]?.push(a), r), {});
  n.top && S(e, t, n.top, i), n.right && S(e, t, n.right, i), n.bottom && S(e, t, n.bottom, i), n.left && S(e, t, n.left, i), n.center && S(
  e, t, n.center, i);
}
l(j, "labelStacks");

// src/measure/box-model/visualizer.ts
var x = {
  margin: "#f6b26ba8",
  border: "#ffe599a8",
  padding: "#93c47d8c",
  content: "#6fa8dca8"
}, G = 30;
function p(e) {
  return parseInt(e.replace("px", ""), 10);
}
l(p, "pxToNumber");
function L(e) {
  return Number.isInteger(e) ? e : e.toFixed(2);
}
l(L, "round");
function P(e) {
  return e.filter((t) => t.text !== 0 && t.text !== "0");
}
l(P, "filterZeroValues");
function Mt(e) {
  let t = {
    top: b.global.window.scrollY,
    bottom: b.global.window.scrollY + b.global.window.innerHeight,
    left: b.global.window.scrollX,
    right: b.global.window.scrollX + b.global.window.innerWidth
  }, o = {
    top: Math.abs(t.top - e.top),
    bottom: Math.abs(t.bottom - e.bottom),
    left: Math.abs(t.left - e.left),
    right: Math.abs(t.right - e.right)
  };
  return {
    x: o.left > o.right ? "left" : "right",
    y: o.top > o.bottom ? "top" : "bottom"
  };
}
l(Mt, "floatingAlignment");
function xt(e) {
  let t = b.global.getComputedStyle(e), { top: o, left: i, right: n, bottom: r, width: a, height: s } = e.getBoundingClientRect(), {
    marginTop: f,
    marginBottom: c,
    marginLeft: u,
    marginRight: h,
    paddingTop: d,
    paddingBottom: C,
    paddingLeft: it,
    paddingRight: rt,
    borderBottomWidth: lt,
    borderTopWidth: at,
    borderLeftWidth: st,
    borderRightWidth: ft
  } = t;
  o = o + b.global.window.scrollY, i = i + b.global.window.scrollX, r = r + b.global.window.scrollY, n = n + b.global.window.scrollX;
  let E = {
    top: p(f),
    bottom: p(c),
    left: p(u),
    right: p(h)
  }, ct = {
    top: p(d),
    bottom: p(C),
    left: p(it),
    right: p(rt)
  }, mt = {
    top: p(at),
    bottom: p(lt),
    left: p(st),
    right: p(ft)
  }, F = {
    top: o - E.top,
    bottom: r + E.bottom,
    left: i - E.left,
    right: n + E.right
  };
  return {
    margin: E,
    padding: ct,
    border: mt,
    top: o,
    left: i,
    bottom: r,
    right: n,
    width: a,
    height: s,
    extremities: F,
    floatingAlignment: Mt(F)
  };
}
l(xt, "measureElement");
function Tt(e, { margin: t, width: o, height: i, top: n, left: r, bottom: a, right: s }) {
  let f = i + t.bottom + t.top;
  e.fillStyle = x.margin, e.fillRect(r, n - t.top, o, t.top), e.fillRect(s, n - t.top, t.right, f), e.fillRect(r, a, o, t.bottom), e.fillRect(
  r - t.left, n - t.top, t.left, f);
  let c = [
    {
      type: "margin",
      text: L(t.top),
      position: "top"
    },
    {
      type: "margin",
      text: L(t.right),
      position: "right"
    },
    {
      type: "margin",
      text: L(t.bottom),
      position: "bottom"
    },
    {
      type: "margin",
      text: L(t.left),
      position: "left"
    }
  ];
  return P(c);
}
l(Tt, "drawMargin");
function Dt(e, { padding: t, border: o, width: i, height: n, top: r, left: a, bottom: s, right: f }) {
  let c = i - o.left - o.right, u = n - t.top - t.bottom - o.top - o.bottom;
  e.fillStyle = x.padding, e.fillRect(a + o.left, r + o.top, c, t.top), e.fillRect(
    f - t.right - o.right,
    r + t.top + o.top,
    t.right,
    u
  ), e.fillRect(
    a + o.left,
    s - t.bottom - o.bottom,
    c,
    t.bottom
  ), e.fillRect(a + o.left, r + t.top + o.top, t.left, u);
  let h = [
    {
      type: "padding",
      text: t.top,
      position: "top"
    },
    {
      type: "padding",
      text: t.right,
      position: "right"
    },
    {
      type: "padding",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "padding",
      text: t.left,
      position: "left"
    }
  ];
  return P(h);
}
l(Dt, "drawPadding");
function kt(e, { border: t, width: o, height: i, top: n, left: r, bottom: a, right: s }) {
  let f = i - t.top - t.bottom;
  e.fillStyle = x.border, e.fillRect(r, n, o, t.top), e.fillRect(r, a - t.bottom, o, t.bottom), e.fillRect(r, n + t.top, t.left, f), e.fillRect(
  s - t.right, n + t.top, t.right, f);
  let c = [
    {
      type: "border",
      text: t.top,
      position: "top"
    },
    {
      type: "border",
      text: t.right,
      position: "right"
    },
    {
      type: "border",
      text: t.bottom,
      position: "bottom"
    },
    {
      type: "border",
      text: t.left,
      position: "left"
    }
  ];
  return P(c);
}
l(kt, "drawBorder");
function Pt(e, { padding: t, border: o, width: i, height: n, top: r, left: a }) {
  let s = i - o.left - o.right - t.left - t.right, f = n - t.top - t.bottom - o.top - o.bottom;
  return e.fillStyle = x.content, e.fillRect(
    a + o.left + t.left,
    r + o.top + t.top,
    s,
    f
  ), [
    {
      type: "content",
      position: "center",
      text: `${L(s)} x ${L(f)}`
    }
  ];
}
l(Pt, "drawContent");
function At(e) {
  return (t) => {
    if (e && t) {
      let o = xt(e), i = Tt(t, o), n = Dt(t, o), r = kt(t, o), a = Pt(t, o), s = o.width <= G * 3 || o.height <= G;
      j(
        t,
        o,
        [...a, ...n, ...r, ...i],
        s
      );
    }
  };
}
l(At, "drawBoxModel");
function U(e) {
  $(At(e));
}
l(U, "drawSelectedElement");

// src/measure/util.ts
var V = require("@storybook/global");
var K = /* @__PURE__ */ l((e, t) => {
  let o = V.global.document.elementFromPoint(e, t), i = /* @__PURE__ */ l((r) => {
    if (r && r.shadowRoot) {
      let a = r.shadowRoot.elementFromPoint(e, t);
      return r.isEqualNode(a) ? r : a.shadowRoot ? i(a) : a;
    }
    return r;
  }, "crawlShadows");
  return i(o) || o;
}, "deepElementFromPoint");

// src/measure/withMeasure.ts
var Z, T = { x: 0, y: 0 };
function Q(e, t) {
  Z = K(e, t), U(Z);
}
l(Q, "findAndDrawElement");
var J = /* @__PURE__ */ l((e, t) => {
  let { measureEnabled: o } = t.globals || {};
  return (0, A.useEffect)(() => {
    if (typeof globalThis.document > "u")
      return;
    let i = /* @__PURE__ */ l((n) => {
      window.requestAnimationFrame(() => {
        n.stopPropagation(), T.x = n.clientX, T.y = n.clientY;
      });
    }, "onPointerMove");
    return globalThis.document.addEventListener("pointermove", i), () => {
      globalThis.document.removeEventListener("pointermove", i);
    };
  }, []), (0, A.useEffect)(() => {
    let i = /* @__PURE__ */ l((r) => {
      window.requestAnimationFrame(() => {
        r.stopPropagation(), Q(r.clientX, r.clientY);
      });
    }, "onPointerOver"), n = /* @__PURE__ */ l(() => {
      window.requestAnimationFrame(() => {
        N();
      });
    }, "onResize");
    return t.viewMode === "story" && o && (globalThis.document.addEventListener("pointerover", i), z(), globalThis.window.addEventListener("\
resize", n), Q(T.x, T.y)), () => {
      globalThis.window.removeEventListener("resize", n), O();
    };
  }, [o, t.viewMode]), e();
}, "withMeasure");

// src/measure/preview.ts
var et = globalThis.FEATURES?.measure ? [J] : [], ot = {
  [Y]: !1
}, Ht = /* @__PURE__ */ l(() => (0, tt.definePreview)({
  decorators: et,
  initialGlobals: ot
}), "default");

// src/measure/index.ts
var Ft = /* @__PURE__ */ l(() => (0, nt.definePreview)(H), "default");
