"use strict";
var n = Object.defineProperty;
var s = Object.getOwnPropertyDescriptor;
var y = Object.getOwnPropertyNames;
var m = Object.prototype.hasOwnProperty;
var p = (e, t) => n(e, "name", { value: t, configurable: !0 });
var c = (e, t) => {
  for (var o in t)
    n(e, o, { get: t[o], enumerable: !0 });
}, u = (e, t, o, a) => {
  if (t && typeof t == "object" || typeof t == "function")
    for (let r of y(t))
      !m.call(e, r) && r !== o && n(e, r, { get: () => t[r], enumerable: !(a = s(t, r)) || a.enumerable });
  return e;
};
var f = (e) => u(n({}, "__esModule", { value: !0 }), e);

// src/component-testing/preview.ts
var x = {};
c(x, {
  default: () => b
});
module.exports = f(x);
var i = require("storybook/internal/instrumenter"), l = require("storybook/preview-api");
var { step: S } = (0, i.instrument)(
  {
    // It seems like the label is unused, but the instrumenter has access to it
    // The context will be bounded later in StoryRender, so that the user can write just:
    // await step("label", (context) => {
    //   // labeled step
    // });
    step: /* @__PURE__ */ p(async (e, t, o) => t(o), "step")
  },
  { intercept: !0 }
), b = /* @__PURE__ */ p(() => (0, l.definePreview)({
  parameters: {
    throwPlayFunctionExceptions: !1
  },
  runStep: S
}), "default");
